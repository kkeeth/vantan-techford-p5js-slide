---
theme: seriph
background: https://source.unsplash.com/collection/94734566/1920x1080
class: "text-center"
lineNumbers: false
info: |
  ## クリエイティブコーディング（p5.js）講義資料#13
  VANTAN Techgord Academy
  Created by [@kuwahara_jsri](https://twitter.com/kuwahara_jsri)
fonts:
  sans: "Josefin Sans"
  serif: "Noto Sans JP"
  mono: "Fira Code"
drawings:
  persist: false
highlighter: prism-xonokai
title: クリエイティブコーディング（p5.js）講義
css: unocss
---

# クリエイティブコーディング（p5.js）講義

VANTAN Techford Academy

### #13 複雑な図形を描く，桜を描く

<div class="pt-12">
  <span @click="$slidev.nav.next" class="px-2 py-1 rounded cursor-pointer" hover="bg-white bg-opacity-10">
    Press Space for next page <carbon:arrow-right class="inline"/>
  </span>
</div>

<div class="abs-br m-6 flex gap-2">
  <button @click="$slidev.nav.openInEditor()" title="Open in Editor" class="text-xl icon-btn opacity-50 !border-none !hover:text-white">
    <carbon:edit />
  </button>
  <a href="https://github.com/kkeeth/vantan-techford-p5js-slide" target="_blank" alt="GitHub"
    class="text-xl icon-btn opacity-50 !border-none !hover:text-white">
    <carbon-logo-github />
  </a>
</div>

---
layout: center
class: text-center
---

# 出席 🙋

---
layout: center
---

# 今日話すこと📋

---

# ▼ 前半: 各種イベント処理/フォーム 基礎

<br />


## 👉 軽く前回の復習
<br />

## 👉 p5.js でのフォーム部品

<br />

## 👉 バラ曲線を描いてみよう

---

# ▼ 後半: vertex を用いて桜を描く

<br />

## 👉 vertex メソッド

* `beginShape(), endShape()`
* `vertex()`

<br />

## 👉 バラ曲線を用いて桜を描く

---
layout: center
---

# 授業資料📋
<br />

[https://vantan-techford-p5js-slide.vercel.app/](https://vantan-techford-p5js-slide.vercel.app/)

<br />

<img width="600" class="mx-auto" src="/assets/1/text.png" alt="講義資料" />

---
layout: center
---

# 軽く前回の復習📝

---
layout: center
---

# イベントとは？

---

# イベントとは？

#### __イベント__ とは我々がプログラムしているシステムやアプリの中で生じた動作や出来事のこと💁

<br />

以下，Web ブラウザ上でのイベントの例．

* PC の画面上でマウスを用いてボタンを押下
* キーボードの何かしらのキーを押下
* Web ページのロードの完了
* ブラウザの画面をリサイズしたり閉じたり
* エラーの発生

などなど．
何かしらの操作により発生する出来事全般です．

---

# Web 上のイベントの一覧

#### Web の場合，イベントはブラウザの画面の中で発火され，それぞれの操作に応じて利用可能な __イベントハンドラ（イベントリスナ）__ と呼ばれるコードが実行される．これを定義することを __イベントハンドラを登録する__ と言ったりする．

<br />

多くのイベントがありますので興味ある方は [イベントリファレンス](https://developer.mozilla.org/ja/docs/Web/Events) をご参照ください💁

---

# イベントハンドラ

#### 何かしらのイベント発火時に実行されるプログラム

例としてボタンをクリックしたときの， `クリックイベント` のコードを見てみましょう💁

```html
<body>
  <button>Change color</button>

  <script>
    // button要素の DOM を取得
    const btn = document.querySelector('button');

    const random = (number) => {
      return Math.floor(Math.random() * (number + 1));
    }

    // ここでイベントリスナをセット
    btn.onclick = function() {
      const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
      document.body.style.backgroundColor = rndCol;
    }
  </script>
</body>
```

---

# イベントハンドラ
<br />

プロパティとして定義しているということは，先程のコードは以下のように書いても同じです．

```js
  const btn = document.querySelector('button');

  const bgChange = () => {
    const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
    document.body.style.backgroundColor = rndCol;
  };

  btn.onclick = bgChange;
```


---

# イベントリスナ

#### __イベントリスナ__ はイベントハンドラの別名と説明されることもありますが厳密には別物です．

<br />

* `イベントリスナ`: イベントの発生を監視し動作するコード
* `イベントハンドラ`: 発生したイベントの応答として動作するコード

<br />

結果的には我々の目から見ると同じ結果になる事が多いので一緒と説明されることも多いようです．

---

# イベントリスナ

#### 先程のイベントハンドラを少し変形したコード例を見てみましょう💁

```js
  // button要素の DOM を取得
  const btn = document.querySelector('button');

  const random = (number) => {
    return Math.floor(Math.random() * (number + 1));
  }

  const bgChange = () => {
    const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
    document.body.style.backgroundColor = rndCol;
  }

  // ここでイベントハンドラをセット
  btn.addEventListener('click', bgChange);
```

---

# イベントハンドラ と イベントリスナのコードの違い
<br />

▼イベントハンドラ

```js
myElement.onclick = functionA;
myElement.onclick = functionB;
```

こちらの場合，functionA は functionB で上書きされてしまう．

<br />

▼イベントリスナ

```js
myElement.addEventListener('click', functionA);
myElement.addEventListener('click', functionB);
```

こちらの場合は，functionA, B 共に実行される．

---
layout: center
---

# p5.js でマウス操作

---

# p5.js でマウス操作

#### マウス操作の組み込み関数やプロパティは思ったよりたくさんある💁（一部抜粋）

<br />

* movedX: ラストフレームと現在のマウスのX座標の差
* movedY: ラストフレームと現在のマウスのY座標の差
* mouseX: マウスのX座標
* mouseY: マウスのY座標
* pmouseX: ラストフレームと現在のマウスのX座標の差
* pmouseY: ラストフレームと現在のマウスのY座標の差
* mouseIsPressed: マウスクリックの状態プロパティ
* mouseMoved(): マウスが移動したかの判定処理
* mouseDragged(): マウスドラッグしたかの判定処理
* mousePressed(): マウスを押したタイミングで呼ばれる
* mouseClicked(): マウスを押して離したタイミングで呼ばれる

これら以外にもいくつかあるので見てみてください．

---
layout: center
---

# p5.js でキーボード操作

---

# p5.js でキーボード操作

#### キーボード操作の組み込み関数やプロパティは思ったより少ない💁

<br />

* keyIsPressed: キーの状態プロパティ
* key: 押されたキー情報を取得
* keyCode: 押されたキーのコードを取得
* keyPressed(): キーを押したタイミングで呼ばれる
* keyReleased(): キーを押して話したタイミングで呼ばれる
* keyTyped(): キーを押したタイミングで呼ばれる（ただし，アクションキーを除く）
* keyIsDown(): 指定したキーが押されたタイミングで呼ばれる

これが全てで，マウスに比べると少なめですね．

---
layout: center
---

# p5.js で DOM 操作

---

# p5.js で DOM 操作

#### DOM 操作の組み込み関数やプロパティも思ったよりたくさんある💁（一部抜粋）

<br />

* crateInput(): 入力要素を生成
* input(): 入力要素に入力された値を要素にセットする
* createButton(): ボタン要素を生成
* createSlider(): スライダー要素を生成
* createElement(): 任意の HTML 要素を生成

<br />

p5.js でよく使うものはこの辺りかなーと言うのが個人の感覚です．

---
layout: center
---

# フォーム周りの HTML 要素

---

# フォーム周りの HTML 要素

#### たくさんの HTML 要素があるが，よく使うものをピックアップ

- `button`
- `input` 系
  - `text`, `password`, `email`, `number`
  - `submit`
  - `checkbox`, `radio`, `label`
  - `date`
  - `range`
- `form`
- `select`, `option`

HTML も色々あるので皆さんで触ってみてください💁

---
layout: center
---

# 前回作ったもの「おえかきボード」 💁

---

<img src="/assets/12/today-art.png" alt="本日の作品" width="800" class="mx-auto" />

コードは [こちら](https://openprocessing.org/sketch/1753931) をご参照ください 🙇

---
layout: center
---

# では，本日の授業へGO 🚀

---
layout: center
---

# p5.js でのフォーム部品

<style>
h1 {
  background-color: #2B90B6;
  background-image: linear-gradient(45deg, #4EC5D4 10%, #146b8c 20%);
  background-size: 100%;
  -webkit-background-clip: text;
  -moz-background-clip: text;
  -webkit-text-fill-color: transparent;
  -moz-text-fill-color: transparent;
}
</style>

---
layout: center
---

# 前回触れなかったフォームのいくつかに触れます💁

---

# 入力フォーム：`createInput()`

```js
/**
 * syntax
 * @param {string} value - 初期値，任意の文字列
 * @param {string} type - <input> 要素の種類を指定 e.g. text, password, number
 */
const input = createInput(value, [type])

/**
 * 横幅を指定
 * @param {number} num - 横幅
 */
input.size(num);

/**
 * 配置場所を絶対値で指定
 * @param {number} x - x座標
 * @param {number} y - y座標
 */
input.position(x, y)

// 値を取得
const hoge = input.value();
```

---

# ボタン：`createButton()`

```js
/**
 * syntax
 *
 * @param {string} label - ボタンのラベル文言を指定
 * @param {string} value - 値（あまり設定することはないかも）
 */
const button = createButton(label, [value]);

/**
 * マウスでボタン押下したときの挙動を指定
 *
 * @param {funciton} fn - 関数
 */
button.mousePressed(fn);
```

---
layout: center
---

# サンプルコード

---

# こんなやつ

<div class="flex mt-10">
  <img src="/assets/13/input-button.png" class="w-1/2" />
  <img src="/assets/13/input-button-show.png" class="w-1/2" />
</div>

---

# `createInput(), createButton()` の公式サンプル

<br />

[公式のサンプル](https://p5js.org/examples/dom-input-and-button.html) のコードを見てみましょう💁

```js
let input, button, greeting;

function setup() {
  createCanvas(710, 400);

  input = createInput('');
  input.position(20, 65);

  button = createButton('submit');
  button.position(input.x + input.width, 65);
  button.mousePressed(greet);

  greeting = createElement('h2', 'what is your name?');
  greeting.position(20, 5);

  textAlign(CENTER);
  textSize(50);
}
（続く）
```

---

```js
（続き）

function greet() {
  const name = input.value();
  greeting.html('hello ' + name + '!');
  input.value('');

  for (let i = 0; i < 200; i++) {
    push();
    fill(random(255), 255, 255);
    translate(random(width), random(height));
    rotate(random(2 * PI));
    text(name, 0, 0);
    pop();
  }
}
```

---

# スライダー：`createSlider()`

```js
/**
 * syntax
 *
 * @param {number} min - 最小値
 * @param {number} max - 最大値
 * @param {number} value - 初期値
 * @param {number} step - メモリのサイズ
 *
 */
const slider = createSlider(min, max, [value], [step]);
```

※ 基本的にはどのフォーム部品も `.position(), .style()` メソッドは利用可能です 💁

---
layout: center
---

# サンプルコード

---

# こんなやつ

<img src="/assets/13/slider.png" class="mx-auto" width="800" />

---

# `createSlider()` の公式サンプル

```js
let rSlider, gSlider, bSlider;

function setup() {
  createCanvas(710, 400);
  textSize(15);

  rSlider = createSlider(0, 255, 100);
  rSlider.position(20, 20);
  gSlider = createSlider(0, 255, 0);
  gSlider.position(20, 50);
  bSlider = createSlider(0, 255, 255);
  bSlider.position(20, 80);
}

function draw() {
  const r = rSlider.value();
  const g = gSlider.value();
  const b = bSlider.value();
  background(r, g, b);
  text('red', rSlider.x * 2 + rSlider.width, 35);
  text('green', gSlider.x * 2 + gSlider.width, 65);
  text('blue', bSlider.x * 2 + bSlider.width, 95);
}
```

---
layout: center
---

# バラ曲線を描いてみよう

<style>
h1 {
  background-color: #2B90B6;
  background-image: linear-gradient(45deg, #4EC5D4 10%, #146b8c 20%);
  background-size: 100%;
  -webkit-background-clip: text;
  -moz-background-clip: text;
  -webkit-text-fill-color: transparent;
  -moz-text-fill-color: transparent;
}
</style>

---

# バラ曲線とは？

<br />

極座標 `(r, θ)` において，以下の方程式で表される曲線のこと💁

<img src="/assets/13/rose-equation.png" class="mx-auto" width="400" />


実際のプロットはこんな感じ →

---

<img src="/assets/13/Rose.svg" class="mx-auto" width="420" />

[画像元: wikipedia](https://commons.wikimedia.org/wiki/File:Rose.svg#/media/ファイル:Rose.svg)

---

# ここでいつもの editor を開きます

#### 手を動かせる方は一緒に書いてみましょう🙋

<br />

<img src="/assets/12/editor-p5js.png" alt="editor p5.jsの画面キャプチャ" width="800" />

---

# 実際に描いてみる

```js
const radius = 150;
let n = 1;
let d = 1;
let x = 0;
let y = 0;
let range = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  stroke(255)
  strokeWeight(4);
}

function draw() {
  background(0);
  translate(width / 2, height / 2);

  for (let a = 0; a < d * TAU; a += 0.01) {
    range = radius * sin(a * (n / d));
    x = range * cos(a);
    y = range * sin(a);
    point(x, y)
  }
}
```

---

この状態で **円が描けていた** ら正しいです💁

後は先程のコードの `n, d` の値を色々変えてみると本来描きたかったものが描けますので，やってみましょう🙋

```diff
  function setup() {
    createCanvas(windowWidth, windowHeight);
    stroke(255)
    strokeWeight(4);
+   frameRate(1);
  }

  function draw() {
  （中略）
+   d++
+   if (d > 9) {
+     n++;
+     d = 1
+   }
+   if (n > 9) {
+     n = 1
+   }
  }
```

---

# アニメーション化
<br />
これでも美しいですが見ていて面白くないのでアニメーションで描くように変更してみましょう 🙋

```diff
  function setup() {
    createCanvas(windowWidth, windowHeight);
    stroke(255)
    strokeWeight(4);
-   frameRate(1);
+   background(0);
  }

  function draw() {
-   background(0);

  （中略）
-   d++
-   if (d > 9) {
-     n++;
-     d = 1
-   }
-   if (n > 9) {
-     n = 1
-   }
  }
```

---

# アニメーション化（続き）

```diff
+ let angle = 0;

  function setup() {
    （中略）
+   angleMode(DEGREES);
  }

  function draw() {
    background(0);
    translate(width / 2, height / 2);

-   for (let a = 0; a < d * TAU; a += 0.01) {
-     range = radius * sin(a * (n / d));
+   range = radius * sin(angle * (n / d));
-     x = range * cos(a);
+   x = range * cos(angle);
-     y = range * sin(a);
+   y = range * sin(angle);
-     point(x, y)
+   point(x, y)
-   }
+   angle++;
  }
```

---

# こうなってれば OK 👍

例： `n = 9, d = 4`

<img src="/assets/13/rose-curve-dotted.png" class="mx-auto mt-2" alt="点描のプロット例" />

---

# 点描ではなく，線描に変更

<br />
点描でも美しいですが，線描も美しいので変更します 🙋ついでに速度も上げます．

```diff
  let x = 0;
  let y = 0;
+ let bx = 0;
+ let by = 0;

  function draw() {
    （中略）

+  bx = x;
+  by = y;
   x = range * cos(angle);
   y = range * sin(angle);
-  point(x, y);
+  line(bx, by, x, y);
-  angle += 2;
+  angle += 4;
  }
```

---

# こうなってれば OK 👍

例： `n = 9, d = 4`

<img src="/assets/13/rose-curve-lined.png" class="mx-auto mt-2" alt="線描のプロット例" />

---

# 時間が余ったら：色を変えてみる
<br />

お決まりの `HSB` モードでランダムに😂

```diff
  function setup() {
    createCanvas(windowWidth, windowHeight);
-   stroke(255)
    strokeWeight(4);
-   background(0);
+   background(100);
    angleMode(DEGREES);
+   colorMode(HSB, 100);
  }

  function draw() {
    translate(width / 2, height / 2);
+   stroke(frameCount % 100, 100, 100);
  }
```

---

# こうなってれば OK 👍

例： `n = 9, d = 4`

<img src="/assets/13/rose-curve-lined-color.png" class="mx-auto mt-2" alt="線描のプロット例" />

---

# 余談
<br />

最後に `rotate()` とか，`translate()` の座標位置を変更していくとか，`angle` の値をもっと大きくすると，どんどん曲線が変化し，バラ曲線の違った面を味わえるので，楽しんでみてください💁

```js
// 回転
rotate(frameCount / 5);

// 中心座標を動かす
translate(width / 2 + 70 * cos(frameCount / 5), height / 2 + 70 * sin(frameCount / 5));

// angle の加算の値を大きくする
angle += 30;
```

---
layout: center
---

# vartex() メソッド

<style>
h1 {
  background-color: #2B90B6;
  background-image: linear-gradient(45deg, #4EC5D4 10%, #146b8c 20%);
  background-size: 100%;
  -webkit-background-clip: text;
  -moz-background-clip: text;
  -webkit-text-fill-color: transparent;
  -moz-text-fill-color: transparent;
}
</style>

---

# `vertex()` メソッドとは？
<br />

その名の通り多角形の `vertex：頂点` を指定するためのメソッド💁

以下のように `beginShape(), endShape()` とセットで使うことを前提とします．

```js
/**
 * syntax
 *
 * @param {number} x - x座標
 * @param {number} y - y座標
 * @param {number} z - z座標 ※WEBGLモードのみ，デフォルトは 0
 */
beginShape();

vertex(x, y, [z]); // これが複数回コールされるイメージ

endShape();
```

---

# `beginShape(), endShape()` メソッド

<br />

こちらも名前の通り，図形描画の開始と終了の宣言．

```js
/**
 * syntax
 *
 * @param {constant} kind - 図形の種類を指定．POINTS, LINES, TRIANGLE_STRIP…etc
 */
beginShape([kind]);

/**
 * syntax
 *
 * @param {constant} mode - 図形を閉じるかどうかを指定．CLOSE か空．
 */
endShape([mode]);
```

それぞれの定数について詳しくは [beginShape()](https://p5js.org/reference/#/p5/beginShape), [endShape()](https://p5js.org/reference/#/p5/endShape) をご参照ください💁

---

# `vertex()` の公式サンプル

```js
function setup() {
  createCanvas(400, 400)
  background(240, 240, 240);
  translate(width / 2, height / 2);

  // 背景色を付けることも可能
  fill(237, 34, 93);
  // 枠線を付けることも可能
  // ただし，点が繋がっていないと今回のように１辺だけ表示されない
  stroke(100, 0, 255);
  strokeWeight(4);

  beginShape();
  vertex(-10, 10);
  vertex(0, 35);
  vertex(10, 10);
  vertex(35, 0);
  vertex(10, -8);
  vertex(0, -35);
  vertex(-10, -8);
  vertex(-35, 0);
  endShape();
}
```

---

# 先程の例

#### 図形の枠線を綺麗に閉じたい場合は，以下の２通り

```js
// 開始の頂点を２回記述
vertex(-10, 10);

// 閉じることを明示
endShape(CLOSE);
```

---
layout: center
---

# バラ曲線を用いて桜を描いてみよう

<style>
h1 {
  background-color: #2B90B6;
  background-image: linear-gradient(45deg, #4EC5D4 10%, #146b8c 20%);
  background-size: 100%;
  -webkit-background-clip: text;
  -moz-background-clip: text;
  -webkit-text-fill-color: transparent;
  -moz-text-fill-color: transparent;
}
</style>

---

# 完成版

<video src="/assets/13/cherry-blossoms.mp4" controls width="600" class="mt-8 mx-auto"></video>

---

# 参考サイト

#### Cinderella というサイトの日本語サイト CinderellaJapan というサイトを参考にします💁

<img src="/assets/13/cinderella-japan.png" alt="CinderellaJapan のキャプチャ" width="600" class="mx-auto my-8" />

Image By [CinderellaJapan](https://sites.google.com/site/cinderellajapan/huanocg/huano-qu-xian)

---

# このような記述が

<img src="/assets/13/cherry-blossoms.png" alt="CinderellaJapan のキャプチャ" width="420" class="mx-auto my-8" />

Image By [CinderellaJapan](https://sites.google.com/site/cinderellajapan/huanocg/huano-qu-xian)

こちらを愚直に実装していきます 🙋

---

# 先程の数式をコメントに記述

#### 何度もサイトとエディタをいったり来たりしないように先に数式をコードにメモしましょう 🙋

```js
/**
 * ulim = 0.8;
 * h(x):=if (x < ulim, 0, ulim - x);
 * r0(x):=(-1)^mod(floor(n / pi * x), 2) * (n / pi * x - floor(n / pi * x)) + mod(floor(n / pi * x), 2);
 * r(x):=r0(x) + 2 * h(r0(x));
 *
 * URL: https://sites.google.com/site/cinderellajapan/huanocg/huano-qu-xian
 */
```

途中に出てくる `mod()` と言う関数は，いわゆる剰余演算子 `%` の処理を意味します．今回は `mod(..., 2)` なので，__２で割った余り__ になります．

`Python` などの他の言語では __モジュロ演算子__ と呼ばれたりします 💁

---

# 実装：準備

#### まずは準備から

```js
const ulim = 0.8

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL)
  noStroke()
}

function draw() {
  background(0);
  // 桜の花びらの数
  petalNumber = 4;
  // 花びらのサイズ
  petalSize = 70;
}

/**
 * h(x):= if (x < ulim, 0, ulim - x);
 * @param {number} x - angle(radians)
 */
function calculateH(x) {
  if (x < ulim) return 0;
  else return ulim - x;
}
```

---

# 実装：桜の花びらを生成

#### とりあえず桜の花びらを生成．`draw()` 内に以下を記述 🙋

```js
 beginShape();
 for (let theta = 0; theta < TAU; theta += 0.01) {
   // n / pi * x
   const A = (this.petalNumber / PI) * theta;

    // mod(floor(n / pi * x), 2)
   const mod = floor(A) % 2;

    // r0(x):=(-1)^mod(floor(n / pi * x), 2) * (n / pi * x - floor(n / pi * x)) + mod(floor(n / pi * x), 2);
   const r0 = pow(-1, mod) * (A - floor(A)) + mod;

    // r(x):=r0(x) + 2 * h(r0(x));
   const r = r0 + 2 * this.calculateH(r0);

   let x = this.petalSize * r * cos(theta);
   let y = this.petalSize * r * sin(theta);
   vertex(x, y);
 }
 endShape(CLOSE);
```

---

# こうなってれば OK 👍

<img src="/assets/13/development-1.png" alt="桜の花びらを表示まで" class="mx-auto" />

---

# 実装：class

#### 桜を複数枚表示するため，class で書き換えましょう 🙋 ※この時点ではエラーになります

```diff
  const ulim = 0.8;
+ const petals = [];
+ const NUM = 80; // 桜の枚数を指定．値は自由に変更してください

  function setup() {
    createCanvas(windowWidth, windowHeight, WEBGL)
    noStroke()
+   for (let i = 0; i < NUM; i++) {
+     petals.push(new CherryBlossom());
+   }
  }

  function draw() {
    background(0);
-   petalNumber = 4;
-   petalSize = 70;
+   for (let petal of petals) {
+     push();
+     petal.update();
+     petal.render();
+     pop();
+   }
  }
```

---

# 実装：class

#### class を実装していきましょう🙋

```js
class CherryBlossom {
  constructor() {
    this.petalNumber = 4
    this.petalSize = random(30, 70)
  }

  // まるっと class 内に移動
  // ついでに if-else を変更
  calculateH(x) {
    if (x < ulim) {
      return 0;
    } else {
      return ulim - x;
    }
  }

  update() {
    // 後で実装します
  }
  （続く）
```

---

# 実装：class

```js
（続き）

  render() {
    // ※ draw() 関数内の beginShape(), endShape() 部分を移植
    beginShape();
    for (let theta = 0; theta < TAU; theta += 0.01) {
      // n / pi * x
      const A = (this.petalNumber / PI) * theta;
      // mod(floor(n / pi * x), 2)
      const mod = floor(A) % 2;
      // r0(x):=(-1)^mod(floor(n/pi*x),2)*(n/pi*x-floor(n/pi*x))+mod(floor(n/pi*x),2);
      const r0 = pow(-1, mod) * (A - floor(A)) + mod;
      // r(x):=r0(x)+2*h(r0(x));
      const r = r0 + 2 * this.calculateH(r0);
      let x = this.petalSize * r * cos(theta);
      let y = this.petalSize * r * sin(theta);
      vertex(x, y);
    }
    endShape(CLOSE);
  }
}
```

---

# 実装：桜に色を付ける

#### 桜に色を付けていきましょう 🙋ついでに桜の花びらを１枚に変更します．

```diff
  constructor() {
    this.petalNumber = 4;
    this.petalSize = random(30, 70);

+   // color settings
+   this.r = floor(random(245, 255));
+   this.g = 219;
+   this.b = 237;
+   this.alpha = random(0.8, 1);
  }

  render() {
+   fill(`rgba(${this.r}, ${this.g} , ${this.b}, ${this.alpha})`);

    beginShape();
-   for (let theta = 0; theta < TAU; theta += 0.01) {
+   for (let theta = 0; theta < TAU / this.petalNumber; theta += 0.01) {
```

※ `this.petalNumber = 1` だと花弁の形が崩れますのでご注意😅

---

# 実装：動きをつける

#### 続いて，現在はすべて中央に固定しているため，動かしていきましょう 🙋

```diff
  class CherryBlossom {
    constructor() {
      （略）

+     // moving petals
+     this.xBase = random(width);
+     this.xRadius = random(50, 100);
+     this.xTheta = random(360);
+     this.xVelocity = random(1, 2);
+     this.yVelocity = this.petalSize / 30;

+     this.vecLocation = createVector(this.xBase, random(height));
    }
    （続く）
```

---

# 実装：動きをつける

```diff
（続き）
    update() {
      // xBase の値を用いたx軸方向の移動範囲を設定
+     this.vecLocation.x = this.xBase + this.xRadius * sin(radians(this.xTheta));

      // 落下を設定
+     this.vecLocation.y += this.yVelocity;

      // 画面下まで移動したら花びらのサイズ分上に移動
+     if (this.vecLocation.y > height) this.vecLocation.y = -this.petalSize;
    }

    render() {
+     translate(this.vecLocation.x - width / 2, this.vecLocation.y - height / 2);
```

---

# 実装：花びらを回転，光の調整

#### 微調整として花びらを回転，光の調整をさせてみましょう 🙋

```diff
  update() {
    // moving range with X base value
    this.vecLocation.x = this.xBase + this.xRadius * sin(radians(this.xTheta));

    // 角速度に速度を加算
+   this.xTheta += this.xVelocity;

  （中略）

  render() {
    fill(`rgba(${this.r}, ${this.g} , ${this.b}, ${this.alpha})`);
    translate(this.vecLocation.x - width / 2, this.vecLocation.y - height / 2);
+   rotateX(radians(this.xTheta));
+   rotateY(radians(this.xTheta));
+   lights();
```

※ p5js 公式の editor ですとかなり暗くなってしまい見辛いため，`lights()` はなくても良さそうです 🙇

---
layout: center
---

# 完成 🎉

<style>
h1 {
  text-align: center;
  margin-bottom: 20px;
}
</style>

---
layout: center
---

# 余ったらプラスアルファで何かを描く

---
layout: center
---

## 次回はイージング, leap() でアニメーションをしてみます 🙋

<style>
h2 {
  background-color: #2B90B6;
  background-image: linear-gradient(45deg, #4EC5D4 10%, #146b8c 20%);
  background-size: 100%;
  -webkit-background-clip: text;
  -moz-background-clip: text;
  -webkit-text-fill-color: transparent;
  -moz-text-fill-color: transparent;
}
</style>
